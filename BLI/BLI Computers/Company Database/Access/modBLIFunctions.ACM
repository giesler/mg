Option Compare Database
Option Explicit

'Database specific declares
Public glMinSaleAmt As Currency
Public glLocalTaxRate As Double
Public glDefDiscountRate As Double
Public DupCurSaleNum As Long

' Constants
Public Const QItemInvn = 1
Public Const QItemLabor = 2
Public Const QItemComputer = 3
Public Const QItemBuyBack = 4
Public Const QItemMiscCost = 5
Public Const SItemInvn = 1
Public Const SItemLabor = 2
Public Const SItemComputer = 3
Public Const SItemBuyBack = 4
Public Const SItemMiscCost = 5
Public Const IItemInvn = 1
Public Const IItemLabor = 2
Public Const IItemComputer = 3
Public Const IItemBuyBack = 4
Public Const IItemMiscCost = 5

Public Const LocBLIRacine = 1

'Check stuff
Dim EngNum(90) As String, StartVal As Integer
Dim StringNum As String, English As String, LoopCount As Integer
Dim Pennies As String, Chunk As String, TensDone As Integer
Dim Hundreds As Integer, Tens As Integer, Ones As Integer

Private Const m_ModName = "modBLIFunctions"

Public Function SecureAuthorize() As Boolean
On Error GoTo SA_Err

If DateDiff("n", glLastSecurityCheck, Date & " " & Time) < 10 Then
  SecureAuthorize = True
  Exit Function
End If

SecureAuthorize = False
DoCmd.OpenForm "fdlgSecPassword", acNormal, , , , acDialog
If Forms![fdlgSecPassword]![chkCorrectPassword] = True Then
  SecureAuthorize = True
  glLastSecurityCheck = Date & " " & Time
End If
DoCmd.Close acForm, "fdlgSecPassword"

Exit Function
SA_Err:
ErrHand "modBLIFunctions", "SecureAuthorize"
Exit Function

End Function

Public Function ViewCalls()
On Error GoTo ViewCalls_Err

DoCmd.OpenForm "frmCallList"

Exit Function
ViewCalls_Err:
ErrHand "modBLIFunctions", "ViewCalls"
Exit Function

End Function

Public Function ViewCall(numCall As Long)

DoCmd.OpenForm "frmCallView", , , "[apkCall] = " & numCall, , acDialog

End Function

Public Function NumViewedCalls() As Integer

NumViewedCalls = DCount("[apkCall]", "tblCall", "[CallDone] = False And [CallRead] = True And [CallFor] = " & glCurUserID)

End Function

Public Function UpdateCallStat()

Dim intNewCalls As Integer, intViewedCalls As Integer

Dim curForm As Form, flgForm As Boolean
On Error Resume Next
Set curForm = Screen.ActiveForm
If Err <> 0 Then
    flgForm = False
Else
    flgForm = True
End If

intNewCalls = NumNewCalls
intViewedCalls = NumViewedCalls

If intNewCalls = 0 Then
    DoCmd.Close acForm, "fdlgMessages"
    If intViewedCalls = 0 Then
        Forms![fmuMain].lblCalls.Visible = False
    Else
        If intViewedCalls = 1 Then
            Forms![fmuMain].lblCalls.Caption = "You have 1 active call."
        Else
            Forms![fmuMain].lblCalls.Caption = "You have " & intViewedCalls & " active calls."
        End If
    End If
Else
    If SysCmd(acSysCmdGetObjectState, acForm, "fdlgMessages") <> acObjStateOpen Then
        DoCmd.OpenForm "fdlgMessages"
    End If
    Forms![fdlgMessages]![lstCalls].Requery
    Forms![fmuMain].lblCalls.Visible = True
    If intNewCalls = 1 Then
        Forms![fmuMain].lblCalls.Caption = "You have 1 new call"
        Forms![fdlgMessages].Caption = "You have 1 new call"
    Else
        Forms![fmuMain].lblCalls.Caption = "You have " & intNewCalls & " new calls"
        Forms![fdlgMessages].Caption = "You have " & intNewCalls & " new calls"
    End If
    If intViewedCalls = 0 Then
        Forms![fmuMain].lblCalls.Caption = Forms![fmuMain].lblCalls.Caption & "."
        Forms![fdlgMessages].Caption = Forms![fdlgMessages].Caption & "."
    ElseIf intViewedCalls = 1 Then
        Forms![fmuMain].lblCalls.Caption = Forms![fmuMain].lblCalls.Caption & ", and 1 active call."
        Forms![fdlgMessages].Caption = Forms![fdlgMessages].Caption & ", and 1 active call."
    Else
        Forms![fmuMain].lblCalls.Caption = Forms![fmuMain].lblCalls.Caption & ", and " & intViewedCalls & " active calls."
        Forms![fdlgMessages].Caption = Forms![fdlgMessages].Caption & ", and " & intViewedCalls & " active calls."
    End If
End If

If flgForm Then curForm.SetFocus

End Function



Public Function GetHourlyRate() As Currency

Dim rval As Variant

Call PrivIniRegister("General", GetDBDir & "database.ini")
rval = PrivGetString("HourlyRate", "47.50")
GetHourlyRate = Val(rval)

End Function

Public Function PrintMailLabel(curCID As Long)
On Error GoTo PrintMailLabel_Err

MsgBox "PrintMailLabel function invalid...", vbExclamation

'Dim rstCInfo As New Recordset, strLabel As String
'OpenWaitForm ("Printing company label...")
'rstCInfo.Open "Tbl_Customers", CurrentProject.Connection, adOpenForwardOnly, adLockReadOnly
'rstCInfo.Find "[Customer #] = " & curCID
'If rstCInfo.NoMatch Then
'    MsgBox "Company ID " & curCID & " was not found.", vbCritical
'Else
'    strLabel = rstCInfo!Name & "|" & rstCInfo!MailAddress & "|" & rstCInfo!MailCity & ", " & rstCInfo!MailState & "  " & rstCInfo!MailZip
'    Call CSPrintLabel(strLabel, 1)
'    CSStopDDE
'End If

'rstCInfo.Close
'Set rstCInfo = Nothing
'CloseWaitForm

Exit Function
PrintMailLabel_Err:
ErrHand "modMisc", "PrintMailLabel"
Exit Function

End Function

Public Function SItemShortDesc(curItem As Long) As String

Select Case curItem
    Case SItemInvn
        SItemShortDesc = "Inv"
    Case SItemLabor
        SItemShortDesc = "Lab"
    Case SItemComputer
        SItemShortDesc = "Comp"
    Case SItemBuyBack
        SItemShortDesc = "buy"
    Case SItemMiscCost
        SItemShortDesc = "Cost"
    Case Else
        SItemShortDesc = "ERR!"
End Select

End Function


Public Function SelectCustomer() As Long
On Error GoTo SelectCustomer_Err

Dim fSC As New Form_fdlgSelectCust, lngCustID As Long

Pause fSC

If fSC.blnNew Then
  If AddNewCust(" ", lngCustID) Then
    SelectCustomer = lngCustID
  End If
ElseIf fSC.blnCancel Then
  SelectCustomer = 0
Else
  SelectCustomer = fSC.lngCustID
End If

Set fSC = Nothing

Exit Function
SelectCustomer_Err:
ErrHand m_ModName, "SelectCustomer"
Exit Function

End Function

Public Function AddNewCust(CustName As String, CustId As Long) As Boolean
On Error GoTo AddNewCust_Err

AddNewCust = False

DoCmd.OpenForm "fdlgCust", , , , acFormAdd, acDialog, CustName

If SysCmd(acSysCmdGetObjectState, acForm, "fdlgCust") = acObjStateOpen Then
    AddNewCust = True
    CustId = Forms![fdlgCust]![apkCust]
    DoCmd.Close acForm, "fdlgCust"
End If

Exit Function
AddNewCust_Err:
ErrHand "modBLIFunctions", "AddNewCust"
Exit Function


End Function

Public Function OpenInvnInfo(InvnId As Variant)
On Error GoTo OpenInvnInfo_Err

If IsNull(InvnId) Then
    MsgBox "You haven't clicked something.", vbExclamation
    Exit Function
End If

DoCmd.OpenForm "fdlgInvnInfo", , , "apkInvn = " & InvnId, , acDialog

Exit Function
OpenInvnInfo_Err:
ErrHand "modBLIFunctions", "OpenInvnInfo"
Exit Function

End Function

Public Function OpenOrderInfo(OrderId As Long)
On Error GoTo OpenOrderInfo_Err

DoCmd.OpenForm "fdlgOrderInfo", , , "apkOrder = " & OrderId, , acDialog

Exit Function
OpenOrderInfo_Err:
ErrHand "modBLIFunctions", "OpenInvnInfo"
Exit Function

End Function

Public Function OpenOrderDetail(OrderId As Long)
On Error GoTo OpenOrderDetail_Err

DoCmd.Close acForm, "fdlgOrderInfo"
DoCmd.Close acForm, "fdlgInvnInfo"

DoCmd.Close acForm, "frmOrderBrowse"
DoCmd.OpenForm "frmOrderBrowse", , , "apkOrder = " & OrderId, , , "cmdShowAll"

Exit Function
OpenOrderDetail_Err:
ErrHand "modBLIFunctions", "OpenOrderDetail"
Exit Function

End Function

Public Function OpenCustForm(CustId As Variant)
On Error GoTo OpenCustForm_Err

If IsNull(CustId) Then
    MsgBox "There is no customer entered or something.", vbExclamation
    Exit Function
End If

DoCmd.OpenForm "fdlgCust", , , "apkCust = " & CustId

Exit Function
OpenCustForm_Err:
ErrHand "modBLIFunctions", "OpenCustForm"
Exit Function

End Function

Public Function OpenSale(SaleId As Variant)
On Error GoTo OpenSale_Err

If IsNull(SaleId) Or SaleId = 0 Then
  MsgBox "There was no sale selected.", vbExclamation
  Exit Function
End If

DoCmd.Close acForm, "frmSale"
DoCmd.OpenForm "frmSale", , , "apkSale = " & SaleId, , , "cmdShowAll"

Exit Function
OpenSale_Err:
ErrHand "modBLIFunctions", "OpenSale"
Exit Function
End Function

Public Function OpenInvoice(InvId As Variant)
On Error GoTo OpenInvoice_Err

If IsNull(InvId) Or InvId = 0 Then
    MsgBox "There was no invoice selected.", vbExclamation
    Exit Function
End If

DoCmd.Close acForm, "frmInvoice"
DoCmd.OpenForm "frmInvoice", , , "apkInv = " & InvId, , , "cmdShowAll"

Exit Function
OpenInvoice_Err:
ErrHand "modBLIFunctions", "OpenInvoice"
Exit Function

End Function

Public Function OpenCustMainForm(CustId As Variant, blnBusiness As Boolean)
On Error GoTo OpenCustMainForm_Err

Dim id As Long

id = Val(CustId)

If IsNull(CustId) Or id = 0 Then
    MsgBox "You must enter some customer information!", vbExclamation
    Exit Function
End If

DoCmd.Close acForm, "fdlgCust"

If blnBusiness = True Then  'business
    DoCmd.OpenForm "frmCust", , , , , , "cmdShowAll CUSTID=" & id
Else
    DoCmd.OpenForm "frmCust", , , , , , "cmdShowAll Home CUSTID=" & id
End If

Exit Function
OpenCustMainForm_Err:
ErrHand "modBLIFunctions", "OpenCustMainForm"
Exit Function

End Function

Public Function PrintEnvelope(CustId As Variant)
On Error GoTo PrintEnvelope_Err

If IsNull(CustId) Then
    MsgBox "There is no customer active.", vbExclamation
    Exit Function
End If

DoCmd.OpenForm "fdlgPrintEnv", , , , , , CustId

Exit Function
PrintEnvelope_Err:
Select Case Err
    Case 2501       'form open cancelled
        Exit Function
    Case Else
        ErrHand "modBLIFunctions", "PrintEnvelope)"
End Select
Exit Function

End Function

Public Function OpenVendor(VendorId As Variant)
On Error GoTo OpenVendor_Err

If IsNull(VendorId) Then
    MsgBox "You don't have a vendor here or something.", vbExclamation
    Exit Function
End If

DoCmd.OpenForm "frmVendors", , , "apkVendor = " & VendorId, , , "cmdShowAll"

Exit Function
OpenVendor_Err:
ErrHand "modBLIFunctions", "OpenVendor"
Exit Function

End Function

Public Function NumNewCalls()

NumNewCalls = DCount("[apkCall]", "tblCall", "[CallRead] = 0 And [CallFor] = " & glCurUserID)

End Function

Public Function PrintDupSales()
On Error GoTo PrintDupSales_Err

Dim rst As ADODB.Recordset
Dim strSQL As String, i As Integer, RecCnt As Integer

strSQL = "Select * From tblSale Where SaleDupPrinted = False"
rst.Open strSQL, CurrentProject.Connection, adOpenKeyset, adLockOptimistic

If rst.BOF And rst.EOF Then
    MsgBox "There are no sales with duplicates that need to be printed.", vbExclamation
    rst.Close
    Set rst = Nothing
    Exit Function
End If

rst.MoveLast
RecCnt = rst.RecordCount
rst.MoveFirst

If MsgBox("Do you want to print the " & RecCnt & " sale duplicates now?", vbQuestion + vbYesNo) = vbYes Then

    OpenStatusForm "Printing duplicates...", RecCnt
    i = 0
    While Not rst.EOF
        i = i + 1
        ' Create table
        UpdateStatusForm i
        DupCurSaleNum = rst!apkSale
        DoCmd.SetWarnings False
        DoCmd.RunSQL "DELETE From ztmpSale"
        DoCmd.OpenQuery "qapprptSaleDup"
        DoCmd.OpenQuery "qapprptSaleAddr"
        DoCmd.OpenQuery "qapprptSalePhone"
        DoCmd.SetWarnings True
        DoCmd.OpenReport "rptSaleDup", acViewNormal
        With rst
            !SaleDupPrinted = True
            .Update
            .MoveNext
        End With
    Wend

End If

CloseStatusForm
rst.Close
Set rst = Nothing

Exit Function
PrintDupSales_Err:
ErrHand "modBLIFunctions", "PrintDupSales"
CloseStatusForm
rst.Close
Set rst = Nothing

Exit Function

End Function

Public Function GetDupCurSaleNum()
GetDupCurSaleNum = DupCurSaleNum
End Function

Public Function OpenQuote(QuoteID As Long)
On Error GoTo OpenQuote_Err

If IsNull(QuoteID) Or QuoteID = 0 Then
  MsgBox "There was no sale selected.", vbExclamation
  Exit Function
End If

DoCmd.Close acForm, "frmQuote"
DoCmd.OpenForm "frmQuote", , , "apkQuote = " & QuoteID, , , "cmdShowAll"

Exit Function
OpenQuote_Err:
ErrHand "modBLIFunctions", "OpenQuote_Err"
Exit Function

End Function


Static Function NumWord(ByVal AmountPassed As Currency) As String

    '** Convert a number to words for filling in the Amount of a check
    '** Example: NumWord(120.45) returns ONE HUNDRED TWENTY AND 45/100
    '** Can handle numbers from 0 to $999,999,999.99
    '** Created by Alan Simpson: Fax (619)756-0159
    '** First working version, not yet fully tuned for speed or brevity.

    '** The array below, and other variables, are dimensioned
    '** in the Declarations section.
    
    Dim msg As String
    '** Fill EngNum array, if it's not filled already)
    If Not EngNum(1) = "One" Then
        EngNum(0) = ""
        EngNum(1) = "One"
        EngNum(2) = "Two"
        EngNum(3) = "Three"
        EngNum(4) = "Four"
        EngNum(5) = "Five"
        EngNum(6) = "Six"
        EngNum(7) = "Seven"
        EngNum(8) = "Eight"
        EngNum(9) = "Nine"
        EngNum(10) = "Ten"
        EngNum(11) = "Eleven"
        EngNum(12) = "Twelve"
        EngNum(13) = "Thirteen"
        EngNum(14) = "Fourteen"
        EngNum(15) = "Fifteen"
        EngNum(16) = "Sixteen"
        EngNum(17) = "Seventeen"
        EngNum(18) = "Eighteen"
        EngNum(19) = "Nineteen"
        EngNum(20) = "Twenty"
        EngNum(30) = "Thirty"
        EngNum(40) = "Forty"
        EngNum(50) = "Fifty"
        EngNum(60) = "Sixty"
        EngNum(70) = "Seventy"
        EngNum(80) = "Eighty"
        EngNum(90) = "Ninety"
    End If

    
    '** Convert incoming Currency value to a string for parsing.
    StringNum = Format$(AmountPassed, "000000000.00")
    
    '** Initialize other variables
    English = ""
    LoopCount = 1
    StartVal = 1
    Pennies = Mid$(StringNum, 11, 2)

    '** Just in case the check is for less than a buck...
    If AmountPassed < 1 Then
        English = "Zero"
    End If

    '** Now do each 3-digit section of number.
    For LoopCount = 1 To 3
        Chunk = Mid$(StringNum, StartVal, 3)
        Hundreds = Val(Mid$(Chunk, 1, 1))
        Tens = Val(Mid$(Chunk, 2, 2))
        Ones = Val(Mid$(Chunk, 3, 1))

        '** Do the hundreds portion of 3-digit number
        If Val(Chunk) > 99 Then
            English = Trim(English & EngNum(Hundreds)) & " Hundred "
        End If

        '** Do the tens & ones portion of 3-digit number
        TensDone = False

        '** Is it less than 10?
        If Tens < 10 Then
            English = Trim(English) & " " & EngNum(Ones)
            TensDone = True
        End If

        '** Is it a teen?
        If (Tens >= 11 And Tens <= 19) Then
            English = English & EngNum(Tens)
            TensDone = True
        End If

        '** Is it Evenly Divisible by 10?
        If (Tens / 10#) = Int(Tens / 10#) Then
           English = English & EngNum(Tens)
           TensDone = True
        End If

        '** Or is it none of the above?
        If Not TensDone Then
            English = English & EngNum((Int(Tens / 10)) * 10)
            English = Trim(English) & " " & EngNum(Ones)
        End If

        '** Add the word "million" if necessary.
        If LoopCount = 1 And Val(Chunk) > 0 Then
            English = Trim(English) + " Million "
        End If

        '** Add the word "thousand" if necessary.
        If LoopCount = 2 And Val(Chunk) > 0 Then
            English = Trim(English) + " Thousand "
        End If

        '** Do pass through second three digits
        StartVal = StartVal + 3
    
    Next LoopCount
    
    '** Done: Return english with pennies tacked on.
    NumWord = Trim(English) & " and " & Pennies & "/100 иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии"
       
    Exit Function

NumWord_Err:
    msg = "Error is " & Error$ & Chr(13) & Chr(10) & "In NumWord()" & Chr(13) & Chr(10)
    MsgBox msg, 16, "Application Error"
    Exit Function

    
End Function


Public Function LoadInvnGrpTree(tv As Variant)

Dim rstGrps As New Recordset, sNodeTxt As String, sRemTxt As String, i As Integer
Dim pNode As Node, cNode As Node, sSQL As String, tNode As Node, flg As Boolean

sSQL = "SELECT apkInvnGrp, InvnGrpDesc FROM tblInvnGrp ORDER BY InvnGrpDesc"
rstGrps.Open sSQL, CurrentProject.Connection, adOpenForwardOnly, adLockReadOnly
Do While Not rstGrps.EOF
  If Not InStr(rstGrps!InvnGrpDesc, "\") Then
    Set pNode = tv.Nodes.Add(, , "g:" & rstGrps!apkInvnGrp, rstGrps!InvnGrpDesc)
  Else
    sRemTxt = rstGrps!InvnGrpDesc
    Set cNode = Nothing
    Do While InStr(sRemTxt, "\")
      sNodeTxt = Left(sRemTxt, InStr(sRemTxt, "\") - 1)
      sRemTxt = Mid(sRemTxt, InStr(sRemTxt, "\") + 1)
      If cNode Is Nothing Then   ' base case, look through base children
        flg = False
        For Each tNode In tv.Nodes
          If tNode.Text = sNodeTxt Then
            flg = True
            cNode = tNode
          End If
        Next tNode
        If Not flg Then Set cNode = tv.Nodes.Add(, , , sNodeTxt)
      Else  ' we already have a cNode, so we want to find the child
        flg = False
        For i = 1 To cNode.Children
          If i = 1 Then
            tNode = cNode.FirstSibling
          Else
            tNode = cNode.Next
          End If
          If tNode.Text = sNodeTxt Then
            flg = True
            cNode = tNode
          End If
        Next i
        If Not flg Then Set cNode = tv.Nodes.Add(cNode, tvwChild, , sNodeTxt)
      End If
    Loop
    ' now we just have a string left which should be added to cNode
    Set pNode = tv.Nodes.Add(cNode, tvwChild, "g:" & rstGrps!apkInvnGrp, rstGrps!InvnGrpDesc)
  End If
  rstGrps.MoveNext
Loop
rstGrps.Close

End Function

Public Function OpenLaborSheet(LaborId As Long)
On Error GoTo OpenLaborSheet_Err

If IsNull(LaborId) Or LaborId = 0 Then
    MsgBox "There was no labor sheet selected.", vbExclamation
    Exit Function
End If

DoCmd.Close acForm, "frmLabor"
DoCmd.OpenForm "frmLabor", , , "apkLabor = " & LaborId, , , "cmdShowAll"

Exit Function
OpenLaborSheet_Err:
ErrHand "modBLIFunctions", "OpenLaborSheet"
Exit Function

End Function

Public Function TermText(TermID As Long, cTotal As Currency, datDate As Date) As String

Dim rst As New Recordset
rst.Open "tblTerm", CurrentProject.Connection, adOpenForwardOnly, adLockReadOnly
rst.Find "apkTerm = " & TermID
If rst.EOF Then
  TermText = "No payment term description available."
  GoTo Exit_TermText
End If

If rst!TermDays = 0 And rst!TermDiscountDays = 0 And rst!TermDiscount = 0 Then
  TermText = "This invoice must be paid upon receipt."
ElseIf rst!TermDays > 0 And rst!TermDiscountDays = 0 And rst!TermDiscount = 0 Then
  TermText = "This invoice must be paid in full by " & Format(CVDate(datDate + rst!TermDays), "m/d/yy")
ElseIf rst!TermDays = 0 And rst!TermDiscount > 0 Then
  TermText = "You may take a " & Format(rst!TermDiscount, "0%") & " discount on this invoice.  " _
    & "The discounted total would be " & Format(cTotal * (1 - rst!TermDiscount), "Currency") _
    & ".  This invoice must be paid upon receipt."
ElseIf rst!TermDays > 0 And rst!TermDiscountDays > 0 And rst!TermDiscount > 0 Then
  TermText = "You may take a " & Format(rst!TermDiscount, "0%") & " discount on this invoice if " _
    & "it is paid by " & Format(CVDate(datDate + rst!TermDiscountDays), "m/d/yy") & ".  The discounted " _
    & "total would be " & Format(cTotal * (1 - rst!TermDiscount), "Currency") & ".  If this invoice is paid " _
    & "after " & Format(CVDate(datDate + rst!TermDiscountDays), "m/d/yy") & " you must remit the total " _
    & "amount by " & Format(CVDate(datDate + rst!TermDays), "m/d/yy") & "."
Else
  TermText = "This invoice must be paid upon receipt."
End If

Exit_TermText:
rst.Close
Set rst = Nothing

End Function